;;*****************************************************************************
;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USBFS.asm
;;   Version: 2.10, Updated on 2015/3/4 at 22:27:56
;;  Generated by PSoC Designer 5.4.3191
;;
;;  DESCRIPTION: USB Device User Module software implementation file
;;
;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API functions
;;        returns. For Large Memory Model devices it is also the caller's
;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
;;        MVW_PP registers. Even though some of these registers may not be modified
;;        now, there is no guarantee that will remain the case in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "USBFS_macros.inc"
include "USBFS.inc"
IF 0x5 & 0x10000000
PSOC_ERROR Please run the USB Setup Wizard.  Device Editor, Right Click the USB User Module
; This message will only appear if the USB Setup Wizard has not be run and the descriptors
; and associated data structures have been created.
; After running the USB Setup Wizard, you must also select the Config/Generate Application
; menu item from PSoC Designer in order to generate USB User Module data structures and
; descriptors.
ENDIF
;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
export  USBFS_Start
export _USBFS_Start
export  USBFS_Stop
export _USBFS_Stop
export  USBFS_bCheckActivity
export _USBFS_bCheckActivity
export  USBFS_bGetConfiguration
export _USBFS_bGetConfiguration
export  USBFS_bGetEPState
export _USBFS_bGetEPState
export  USBFS_wGetEPCount
export _USBFS_wGetEPCount
export  USBFS_LoadInEP
export _USBFS_LoadInEP
export  USBFS_LoadInISOCEP
export _USBFS_LoadInISOCEP
export  USBFS_EnableOutEP
export _USBFS_EnableOutEP
export  USBFS_EnableOutISOCEP
export _USBFS_EnableOutISOCEP
export  USBFS_DisableOutEP
export _USBFS_DisableOutEP
export  USBFS_bReadOutEP
export _USBFS_bReadOutEP
export  USBFS_Force
export _USBFS_Force
export  USBFS_bGetEPAckState
export _USBFS_bGetEPAckState
;export USBFS_Suspend
;export _USBFS_Suspend
;export USBFS_Resume
;export _USBFS_Resume
export  USBFS_bRWUEnabled
export _USBFS_bRWUEnabled
export  USBFS_SetPowerStatus
export _USBFS_SetPowerStatus

AREA InterruptRAM (RAM, REL, CON)
;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------

;-----------------------------------------------
;  Variable Allocation
;-----------------------------------------------
export USBFS_APITemp
 USBFS_APITemp:                         BLK   2 ; Two bytes of temporary
                                                ; storage shared by the API
                                                ; functions
export USBFS_APIEPNumber, _USBFS_APIEPNumber
_USBFS_APIEPNumber:
 USBFS_APIEPNumber:                    BLK   1 ; API storage for speed
export USBFS_APICount, _USBFS_APICount
_USBFS_APICount:
 USBFS_APICount:                       BLK   1 ; API storage for speed

export USBFS_bActivity, _USBFS_bActivity
_USBFS_bActivity:
 USBFS_bActivity:                      BLK   1 ; Activity flag (Shared between the ISR and API)
;-----------------------------------------------
;  Constant Data Allocation
;-----------------------------------------------
IF	(TOOLCHAIN & HITECH)
  AREA lit (ROM,REL,CON)
ELSE
  AREA lit (ROM,REL,CON,LIT)
ENDIF
export USBFS_USB_EP_BIT_LOOKUP
.LITERAL
USBFS_USB_EP_BIT_LOOKUP:  ;
    DB     01H                       ; EP0
    DB     02H                       ; EP1
    DB     04H                       ; EP2
    DB     08H                       ; EP3
    DB     010H                      ; EP4
.ENDLITERAL

AREA UserModules (ROM, REL)

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_Start
;
;  DESCRIPTION:    Starts the USB User Module
;                    Sets the device selection
;                    Set the configuration to unconfigured
;                    Enables the SIE for Address 0
;                    Enables the USB pullup (D- for low speed, D+ for full speed)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A is the desired device
;                X is the operation voltage
;
;  RETURNS:              Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_Start:
_USBFS_Start:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX >USBFS_bCurrentDevice   ; Set the IDX_PP to the right page
    push    X
    mov     [USBFS_bCurrentDevice], A  ; The app selects the desired device

    mov     [USBFS_TransferType], USB_TRANS_STATE_IDLE   ; Transaction Idle State
    mov     [USBFS_Configuration], 0   ; Unconfigured
    mov     [USBFS_DeviceStatus], 0    ; Clears device status

    mov     [USBFS_EPDataToggle], 0    ; Clear all EP data toggles

    mov     reg[TMP_DR0], 0            ; EP1 start address in PMA space
    mov     reg[TMP_DR1], 64           ; EP2 start address in PMA space
    mov     reg[TMP_DR2], 128          ; EP3 start address in PMA space
    mov     reg[TMP_DR3], 192          ; EP4 start address in PMA space

;    mov     X, USB_MAX_EP_NUMBER      ; Set up loop to clear all of the endpoint data items
; Flow or jump here to clear the data for the next endpoint
;.loop:
;    mov     [X + USBFS_EPDataToggle], 0    ; Or in the toggle
;    dec     X                         ; Are we done?
;    jnz     .loop                     ; Jump to do another endpoint

IF (USBFS_CLASS & USB_CLASS_HID)
    ; Initialize USBFS_Protocol variable to comply with HID 7.2.6 Set_Protocol Request: 
    ; "When initialized, all devices default to report protocol." 
    mov     X, 3-1                     ;number of interfaces -1 
.loop:
    mov     [X + USBFS_Protocol], 1    ; Protocol = Report
    dec     X                                ;Are we done?
    jnc     .loop                            ;Jump to do another interface
ENDIF

; Flow here to enable the SIE

    mov     reg[USBFS_ADDR], USB_ADDR_ENABLE   ; Enable Address 0
    mov     reg[USBFS_USBIO_CR0], USB_AUTO_DPDM

; Set the Operating Voltage at which the chip will run
    pop     A
    M8C_SetBank1
    mov     reg[USBFS_USB_CR1], A
    M8C_SetBank0
;   TODO
    mov     reg[USBFS_EP0MODE], USB_MODE_STALL_IN_OUT   ; ACK Setup/Stall IN/OUT
    M8C_EnableIntMask USBFS_INT_REG, (USBFS_INT_RESET_MASK | USBFS_INT_EP0_MASK)

;   Enable the pullup so we can start to rock and roll
    mov     reg[USBFS_USBIO_CR1], USB_PULLUP_ENABLE   ; Pullup D+

    RAM_EPILOGUE RAM_USE_CLASS_3
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_Stop
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: None
;
;  RETURNS:   Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_Stop:
_USBFS_Stop:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page
    mov     A, 0
    mov     [USBFS_bCurrentDevice], A  ; The app selects the desired device

    mov     [USBFS_TransferType], USB_TRANS_STATE_IDLE   ; Transaction Idle State
    mov     [USBFS_Configuration], A   ; Unconfigured
    mov     [USBFS_DeviceStatus], A    ; Clears device status
    mov     reg[USBFS_ADDR], A         ; Clear the addfress and Address 0

    and     reg[USBFS_USBIO_CR1], ~USB_PULLUP_ENABLE   ; Release D-
    M8C_DisableIntMask USBFS_INT_REG, 0xff   ; Disable USB interrupts

    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bCheckActivity
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS: Nothing
;
;  RETURNS:   A is a flag that indicates bus activity
;
;  SIDE EFFECTS: ;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bCheckActivity:
_USBFS_bCheckActivity:
    RAM_PROLOGUE RAM_USE_CLASS_1
    M8C_SetBank1
    mov    A, reg[USBFS_USB_CR1]       ; USB Activity bit indicates activity
    and    A, USB_BUS_ACTIVITY         ; Activity?
    jz     .no_activity                ; Jump on no activity?
; Flow here on bus activity
    and    reg[USBFS_USB_CR1], ~USB_BUS_ACTIVITY    ; Clear the activity flag
    mov    A, 1                        ; Return true
    jmp    .done
; Jump here on no activity
.no_activity:
    mov    A, 0                        ; Return false
; Jump or flow here to clear the activity bit, then return
.done:
    M8C_SetBank0
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetConfiguration
;
;  DESCRIPTION:   Returns the current configuration number
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None
;
;  RETURNS:      A contains the current configuration number
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bGetConfiguration:
_USBFS_bGetConfiguration:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_Configuration
    mov     A, [USBFS_Configuration]
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetEPState
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the endpoint number
;
;  RETURNS:      A contains the endpoint state
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bGetEPState:
_USBFS_bGetEPState:
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_IDX >USBFS_EndpointAPIStatus
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to enable an endpoint
    mov     X, A                       ; Endpoint number is the index
    mov     A, [X+USBFS_EndpointAPIStatus]; Get the state
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION



;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bRWUEnabled
;
;  DESCRIPTION:   Returns 1 if Remote Wake Up is enabled, otherwise 0
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:   None
;
;  RETURNS:     A: 1--Remote Wake Up Enabled
;                  0--Remote Wake Up Disabled
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.SECTION
 USBFS_bRWUEnabled:
_USBFS_bRWUEnabled:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_DeviceStatus
    tst     [USBFS_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
    jnz     .enabled                   ; Jump if enabled
; Flow here if RWU is disabled
    mov     A, 0                       ; Return disabled
    jmp     .exit                      ; Go to the common exit
; Jump when RWU is enabled
.enabled:
    mov     A, 1                       ; Return enabled
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetEPCount
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A contains the Endpoint Number
;
;  RETURNS:              A and X contain a WORD that indicate the values stored in the
;                Count registers of the Endpoint
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
.SECTION
 USBFS_wGetEPCount:
_USBFS_wGetEPCount:
    RAM_PROLOGUE RAM_USE_CLASS_1
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .invalid_ep                ; Bail out
; Flow here to get the endpoint count
    asl     A                          ; Multiply the index by two to get to the value
    mov     X, A                       ; Endpoint number is the index
    mov     A, reg[X+USBFS_EP1CNT1 - 1]   ; Here is the count
    sub     A, 2
    push    A
    dec     X
    mov     A, reg[X+USBFS_EP1CNT1 - 1]   ; Here is the count
    and     A, 0x01
    mov     X, A
    pop     A
    jmp     .exit                      ; Go to the common exit
; Jump here for an invalid endpoint
.invalid_ep:
    mov     A, 0                       ; Return 0 for an invalid ep
; Jump or flow here for a common exit
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_LoadInEP and USBFS_LoadInISOCEP
;
;  DESCRIPTION:    This function loads the specified USB endpoint with
;                  the data specified.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-8] Toggle
;     [SP-7] MSB of Count to send
;     [SP-6] LSB of Count to send
;     [SP-5] MSB of data array address
;     [SP-4] LSB of data array address
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_TYPE:        equ -1
; -2 and -3 is the return address to caller
EP_NUM:     equ -4                       ; Endpoint Number
DATA_LSB:   equ -5           ; LSB pointer of data
DATA_MSB:   equ -6           ; MSB pointer of data
CNTLEN_LSB: equ -7
CNTLEN_MSB: equ -8           ; Length of data to send
TOGGLE:     equ -9

 USBFS_LoadInISOCEP:
_USBFS_LoadInISOCEP:
    mov     A, USB_MODE_ISO_IN
    push    A
    jmp             BodyLoadIN_USBFS
 USBFS_LoadInEP:
_USBFS_LoadInEP:
    mov     A, USB_MODE_ACK_IN
    push    A
BodyLoadIN_USBFS:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3

    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK
    mov     X, SP
    mov     A, [X+EP_NUM]
    cmp     A, USB_MAX_EP_NUMBER+1     ; Range check
    jnc     .exit                      ; Bail out

    ;SET THE COUNT
    mov     A, [X+CNTLEN_MSB]          ; Get the MSB of the Count
    and     A, 0x01                    ; Mask off the count bit
    mov     [USBFS_APITemp+1], A       ; Save the count
    mov     A, [X+CNTLEN_LSB]          ; Get the LSB of the Count
    mov     [USBFS_APITemp], A         ; Save the count


        ;  Perform normal data toggle or bypass?
    push    X
    mov     A, [X+TOGGLE]
    jnz     .normalToggle
		; the endpoint ISR automatically toggles the endpoint, so to support
		; the idea of not having the toggle change we must untoggle here.
    mov     A, <USBFS_USB_EP_BIT_LOOKUP           ; calculate the address LSB
    add     A, [X+EP_NUM]           ; Get the Endpoint number
    mov     X, >USBFS_USB_EP_BIT_LOOKUP           ; calculate the address MSB
    swap    A, X
	adc     A, 0
	romx
	pop     X	                            ; Restore X to obtain the endpt correctly in the next block
	push    X

;    INDEX   USBFS_USB_EP_BIT_LOOKUP ; Get the bit mask
    xor     [USBFS_EPDataToggle], A ; Retoggle the toggle

.normalToggle:
    mov     A, <USBFS_USB_EP_BIT_LOOKUP           ; calculate the address LSB
    add     A, [X+EP_NUM]           ; Get the Endpoint number
    mov     X, >USBFS_USB_EP_BIT_LOOKUP           ; calculate the address MSB
    swap    A, X
	adc     A, 0
	romx	;   now A contains the toggle

;    INDEX   USBFS_USB_EP_BIT_LOOKUP ; Get the bit mask
    pop     X	 ;do before the and so the zero flag won't be corrupted.
    and     A, [USBFS_EPDataToggle]
    jz      .toggle0

    and      [USBFS_APITemp+1], ~USB_CNT_TOGGLE ; Set the data toggle
    jmp     .toggle_done
.toggle0:
    or     [USBFS_APITemp+1], USB_CNT_TOGGLE

.toggle_done:

    mov     X, SP
    mov     A, [X+EP_NUM]               ; Get the Endpoint number
    asl     A                           ; Double the ep number for proper cnt access
    mov     X, A                        ; Make it into an index
    mov     A, [USBFS_APITemp]          ; Retrieve the saved MSB
    mov     reg[X+USBFS_EP1CNT1 - 1], A     ; Write it into the register
    dec     X                           ; Decrement the index to access the LSB
    mov     A, [USBFS_APITemp+1]        ; Retrieve the saved LSB
    mov     reg[X+USBFS_EP1CNT1 - 1], A     ; Write it into the register

; It's Time to move the data

; First we need to determine where within the PMA the EP Start Address is
    mov     X, SP                       ; Get the Stack Pointer
    mov     A, [X+EP_NUM]               ; Get the Endpoint number
    mov     X, A                        ; Use the EP number as an index
    mov     A, reg[X+TMP_DR0-1]         ; Get the address of ep from tmp register

   M8C_SetBank1
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE1
   M8C_DisableGInt
   mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
   M8C_EnableGInt
   jmp   .Continue1
.DontTouchGIE1:
   mov   reg[PMA0_WA], A                ; Set the Write pointer of our pma to ep space
.Continue1:
	M8C_SetBank0

; Now we are ready to start moving data
    mov     X, SP
    and     [X+CNTLEN_MSB], 0x01        ; Mask off the MSB bit
    jnz     .start_send                 ; If it is high then we have 256 bytes
    mov     A, [X+CNTLEN_LSB]           ; Check the LSB register
    jz      .done                       ; If it is 0 then we have a 0 length packet
.start_send:
    mov     A, [X+DATA_LSB]
    push    A
IF SYSTEM_LARGE_MEMORY_MODEL
    mov     A, [X+DATA_MSB]
    mov     reg[IDX_PP], A
ENDIF
    pop     X

.loop:
    mov     A, [X]
    mov     reg[PMA0_DR], A
    inc     X
    dec     [USBFS_APITemp]
    jnz     .loop

    RAM_SETPAGE_IDX2STK
.done:
    mov     X, SP
    mov     A, [X+EP_NUM]
    mov     X, A

   M8C_SetBank1
   mov   A, reg[X+TMP_DR0-1]           ; Get the value of the PMA start Address
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE2
   M8C_DisableGInt
   mov   reg[X + PMA0_RA], A           ; Load it into EP PMA so pre-fetch occurs
   M8C_EnableGInt
   jmp   .Continue2
.DontTouchGIE2:
   mov   reg[X + PMA0_RA], A           ; Load it into EP PMA so pre-fetch occurs
.Continue2:
	M8C_SetBank0

    push    X
    mov     X, SP
    mov     A, [X+EP_TYPE-1]
    pop     X

    ; Check that we aren't halted
    RAM_SETPAGE_IDX >USBFS_EndpointAPIStatus
    cmp     [X + USBFS_EndpointAPIStatus], NO_EVENT_ALLOWED    ; Get the state
    jz      .exit

    mov     [X + USBFS_EndpointAPIStatus], NO_EVENT_PENDING   ; Set the state
    M8C_SetBank1
    mov     reg[X + USBFS_EP1MODE-1], A ; Enable the endpoint
    M8C_SetBank0

.exit:
    pop     A                          ; Clean up EP_TYPE
    RAM_EPILOGUE RAM_USE_CLASS_3
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_EnableOutEP and
;                                 USBFS_EnableOutISOCEP
;
;  DESCRIPTION:    This function enables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the endpoint number
;
;  RETURNS:        None
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
USBFS_EnableOutISOCEP:
_USBFS_EnableOutISOCEP:
    mov     X, USB_MODE_ISO_OUT
    push    X
    jmp     BodyEnableOut_USBFS
 USBFS_EnableOutEP:
_USBFS_EnableOutEP:
    mov     X, USB_MODE_ACK_OUT
    push    X
BodyEnableOut_USBFS:
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_IDX >USBFS_EndpointAPIStatus

    cmp     A, 0                       ; Can't enable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .exit                      ; Bail out
; Flow here to enable an endpoint
    mov     X, A                       ; Endpoint number is the index

    ; Check that we aren't halted
    cmp     [X + USBFS_EndpointAPIStatus], NO_EVENT_ALLOWED    
    jz      .exit

    push    X
    mov     [X+USBFS_EndpointAPIStatus], NO_EVENT_PENDING   ; For the API
    mov     A, X
    asl     A
    mov     X, A
    mov     reg[X+EP1_CNT1-1], 64
    M8C_SetBank1
    pop     X
    mov     A, reg[X+TMP_DR0-1]
    mov     reg[X+PMA0_WA], A
    mov     A, reg[X+USBFS_EP1MODE-1]  ; Unlock the mode register
    pop     A

    mov     reg[X+USBFS_EP1MODE-1], A  ; Enable the endpoint
    M8C_SetBank0
    jmp         .DoneEnableOut
; Jump or flow here for a common exit
.exit:
    pop     A
.DoneEnableOut:
    RAM_EPILOGUE RAM_USE_CLASS_3
    ret                                ; All done
.ENDSECTION

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_DisableOutEP
;
;  DESCRIPTION:    This function disables an OUT endpoint.  It should not be
;                  called for an IN endpoint.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A the endpoint number
;
;  RETURNS:               none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
.SECTION
 USBFS_DisableOutEP:
_USBFS_DisableOutEP:
    cmp     A, 0                       ; Can't disable EP0
    jz      .exit                      ; Bail out
    cmp     A, (USB_MAX_EP_NUMBER + 1)   ; Range check
    jnc     .exit                      ; Bail out
; Flow here to disable an endpoint
    mov     X, A                       ; Endpoint number is the index
    M8C_SetBank1
    mov     A, reg[X+USBFS_EP1MODE-1]  ; Unlock the mode register
    mov     reg[X+USBFS_EP1MODE-1], USB_MODE_NAK_OUT   ; Disable the endpoint
    M8C_SetBank0
; Jump or flow here for a common exit
.exit:
    ret                                ; All done
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_Force
;
;  DESCRIPTION:    Force the J/K/SE0 State of D+/D-
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A: USB_FORCE_J
;                    USB_FORCE_K
;                    USB_FORCE_SE0
;                    USB_FORCE_NONE
;
;  RETURNS:       Nothing
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_Force:
_USBFS_Force:
    mov    reg[USBFS_USBIO_CR0], A
    ret                                ; Exit
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bReadOutEP
;
;  DESCRIPTION:    This function reads the data from the USB Out endpoint
;                  and loads it into the specified buffer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;     [SP-7] MSB of Count to read
;     [SP-6] LSB of Count to read
;     [SP-5] MSB of data array address to put data in
;     [SP-4] LSB of data array address to put data in
;     [SP-3] Endpoint Number
;
;  RETURNS:
;     none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
;    Currently only the page pointer registers listed below are modified:
;          CUR_PP
;          IDX_PP
;
EP_NUMR:     equ -3                       ; Endpoint Number
DATA_LSBR:   equ -4           ; MSB pointer of data
DATA_MSBR:   equ -5           ; LSB pointer of data
CNTLEN_LSBR: equ -6           ; Length of data to send
CNTLEN_MSBR: equ -7

 USBFS_bReadOutEP:
_USBFS_bReadOutEP:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_CUR >USBFS_bCurrentDevice   ; Set the CUR_PP to the right page
    RAM_SETPAGE_IDX2STK
    mov     X, SP
    mov     A, [X+EP_NUMR]
    cmp     A, USB_MAX_EP_NUMBER+1     ; Range check
    jnc     .exit                      ; Bail out

    ;Get the count value passed
    mov     A, [X+CNTLEN_MSBR]         ; Get the MSB of the Count
    and     A, 0x01                    ; Mask off the count bit
    mov     [USBFS_APITemp], A         ; Save the count
    mov     A, [X+CNTLEN_LSBR]         ; Get the LSB of the Count
    mov     [USBFS_APITemp+1], A       ; Save the count

    ;Determine which is smaller the requested data or the available data
    mov     A, [X+EP_NUMR]              ; Get the Endpoint number
    asl     A                           ; Double the ep number for proper cnt access
    mov     X, A                        ; Make it into an index
    mov     A, reg[X+USBFS_EP1CNT1 - 2]     ; Get the Real count MSB
    and     A, 0x01                     ; Mask off the LSB
    cmp     A, [USBFS_APITemp]          ; Are they equal
    jz      .MSBEqual                   ; If they are check if they are 1
    jc      .CountDetermined            ;If the requested count is smaller use it
    mov     [USBFS_APITemp], A          ; Else use the actual
    mov     A, reg[X+USBFS_EP1CNT1 - 1]     ; Get the Real count LSB
    mov     [USBFS_APITemp + 1], A      ; Else use the actual
    jmp     .CountDetermined
.MSBEqual:
    mov     A, [USBFS_APITemp]
    jz      .CheckLSB
    mov     [USBFS_APITemp + 1], 0
    jmp         .CountDetermined
.CheckLSB:
    mov     A, reg[X+USBFS_EP1CNT1 - 1]     ; Get the Real count LSB
    cmp     A, [USBFS_APITemp+1]        ; Are they equal
    jz      .CountDetermined            ; If they are check if they are 1
    jnc      .CountDetermined           ;If the requested count is smaller use it
    mov     [USBFS_APITemp+1], A        ; Else use the actual
.CountDetermined:

; First we need to determine where within the PMA the EP Start Address is
    mov     X, SP                       ; Get the Stack Pointer
    mov     A, [X+EP_NUMR]              ; Get the Endpoint number
    mov     X, A                        ; Use the EP number as an index
    mov     A, reg[X+TMP_DR0-1]         ; Get the address of ep from tmp register

   M8C_SetBank1
   tst   reg[CPU_F], 0x01
   jz    .DontTouchGIE3
   M8C_DisableGInt
   mov   reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
   M8C_EnableGInt
   jmp   .Continue3
.DontTouchGIE3:
   mov   reg[PMA0_RA], A                ; Set the Read pointer of our pma to ep space
.Continue3:
	M8C_SetBank0

; Now we are ready to start moving data
    and     [USBFS_APITemp], 0x01       ; Mask off the MSB bit
    jnz     .start_send                 ; If it is high then we have 256 bytes
    mov     A, [USBFS_APITemp+1]        ; Check the LSB register
    jz      .done                       ; If it is 0 then we have a 0 length packet

.start_send:
    mov     X, SP
    mov     A, [X+DATA_LSBR]            ; Get the LSB of the pointer
    push    A                           ; save on stack
IF SYSTEM_LARGE_MEMORY_MODEL
    mov     A, [X+DATA_MSBR]            ; Get the MSB of the pointer
    mov     reg[IDX_PP], A              ; Use as value for IDX_PP
ENDIF
    pop     X                           ; Get the LSB again

        ;;
        ;; 24Mhz read PMA workaround (kvn)
        ;;
    M8C_SetBank1
    mov     A, reg[OSC_CR0]
    push    A
    and     A, 0xf8 ;clear the clock bits (briefly chg the cpu_clk to 3Mhz)
    or      A, 0x02 ;will set clk to 12Mhz
    mov     reg[OSC_CR0], A ;clk is now set at 12Mhz
    M8C_SetBank0

.loop:
    mov     A, reg[PMA0_DR]             ; Get the data from the PMA space
    mov    [X], A                       ; save it in data array
    inc     X                           ; increment the pointer
    dec     [USBFS_APITemp+1]           ; decrement the counter
    jnz     .loop                       ; wait for count to zero out

        ;;
        ;; 24Mhz read PMA workaround (back to previous clock speed (kvn)
        ;;
    pop     A ;recover previous reg[OSC_CR0] value
    M8C_SetBank1
    mov     reg[OSC_CR0], A ;clk is now set at previous value (probably 24Mhz)
    M8C_SetBank0
        ;;
        ;; end 24Mhz read PMA workaround (kvn)
        ;;

    RAM_SETPAGE_IDX2STK
    mov     X, SP
    mov     A, [X+EP_NUMR]
    asl     A
    mov     X, A
    mov     A, reg[X+USBFS_EP1CNT1 - 1]     ; Get the Real count LSB
    sub     A, 2
.done:
.exit:
    RAM_EPILOGUE RAM_USE_CLASS_3
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_bGetEPAckState
;
;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
;                 an endpoint
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A is the Endpoint Number
;
;  RETURNS:       A is 0 if ACK bit is not set and non-zero if it is
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_bGetEPAckState:
_USBFS_bGetEPAckState:
    mov    X, A
    M8C_SetBank1
    mov    A, reg[X + USBFS_EP1MODE-1]
    M8C_SetBank0
    and    A, 0x10
    ret                                ; Exit
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_SetPowerStatus
;
;  DESCRIPTION:    Set The Current Power status.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:      A contains the power status
;
;  RETURNS:        None
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 USBFS_SetPowerStatus:
_USBFS_SetPowerStatus:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR >USBFS_DeviceStatus
    cmp     A, 0
    jz      .bus_powered
    or      [USBFS_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
    jmp     .done
.bus_powered:
    and     [USBFS_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
.done:
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret                                ; All done
.ENDSECTION
