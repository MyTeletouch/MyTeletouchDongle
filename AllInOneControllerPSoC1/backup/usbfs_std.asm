;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USBFS_std.asm
;;  Version: 2.10, Updated on 2015/3/4 at 22:27:56
;;  Generated by PSoC Designer 5.4.3191
;;
;;  DESCRIPTION: USB Device User Module software implementation file.
;;
;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API functions
;;        returns. For Large Memory Model devices it is also the caller's
;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and
;;        MVW_PP registers. Even though some of these registers may not be modified
;;        now, there is no guarantee that will remain the case in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "USBFS_macros.inc"
include "USBFS.inc"

;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------

AREA bss (RAM, REL)

;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------
;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------

AREA UserModules (ROM, REL)

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_Not_Supported
;
;  DESCRIPTION:
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

; d2h_std_dev
IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_00
USBFS_CB_d2h_std_dev_00:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_01
USBFS_CB_d2h_std_dev_01:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_02
USBFS_CB_d2h_std_dev_02:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_03
USBFS_CB_d2h_std_dev_03:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_04
USBFS_CB_d2h_std_dev_04:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_05
USBFS_CB_d2h_std_dev_05:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_06
USBFS_CB_d2h_std_dev_06:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_07
USBFS_CB_d2h_std_dev_07:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_dev_08
USBFS_CB_d2h_std_dev_08:
ENDIF

; h2d_std_dev
IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_00
USBFS_CB_h2d_std_dev_00:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_01
USBFS_CB_h2d_std_dev_01:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_02
USBFS_CB_h2d_std_dev_02:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_03
USBFS_CB_h2d_std_dev_03:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_04
USBFS_CB_h2d_std_dev_04:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_05
USBFS_CB_h2d_std_dev_05:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_06
USBFS_CB_h2d_std_dev_06:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_07
USBFS_CB_h2d_std_dev_07:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_08
USBFS_CB_h2d_std_dev_08:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_dev_09
USBFS_CB_h2d_std_dev_09:
ENDIF

; d2h_std_ifc
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_00
USBFS_CB_d2h_std_ifc_00:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_01
USBFS_CB_d2h_std_ifc_01:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_02
USBFS_CB_d2h_std_ifc_02:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_03
USBFS_CB_d2h_std_ifc_03:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_04
USBFS_CB_d2h_std_ifc_04:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_05
USBFS_CB_d2h_std_ifc_05:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_06
USBFS_CB_d2h_std_ifc_06:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_07
USBFS_CB_d2h_std_ifc_07:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_08
USBFS_CB_d2h_std_ifc_08:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_09
USBFS_CB_d2h_std_ifc_09:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ifc_10
USBFS_CB_d2h_std_ifc_10:
ENDIF

; h2d_std_ifc
IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_00
USBFS_CB_h2d_std_ifc_00:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_01 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_01
USBFS_CB_h2d_std_ifc_01:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_02 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_02
USBFS_CB_h2d_std_ifc_02:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_03 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_03
USBFS_CB_h2d_std_ifc_03:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_04 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_04
USBFS_CB_h2d_std_ifc_04:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_05 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_05
USBFS_CB_h2d_std_ifc_05:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_06 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_06
USBFS_CB_h2d_std_ifc_06:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_07 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_07
USBFS_CB_h2d_std_ifc_07:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_08 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_08
USBFS_CB_h2d_std_ifc_08:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_09 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_09
USBFS_CB_h2d_std_ifc_09:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_10 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_10
USBFS_CB_h2d_std_ifc_10:
ENDIF
IF (USB_CB_SRC_h2d_std_ifc_11 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ifc_11
USBFS_CB_h2d_std_ifc_11:
ENDIF

; d2h_std_ep
IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_00
USBFS_CB_d2h_std_ep_00:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_01 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_01
USBFS_CB_d2h_std_ep_01:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_02 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_02
USBFS_CB_d2h_std_ep_02:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_03 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_03
USBFS_CB_d2h_std_ep_03:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_04 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_04
USBFS_CB_d2h_std_ep_04:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_05 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_05
USBFS_CB_d2h_std_ep_05:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_06 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_06
USBFS_CB_d2h_std_ep_06:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_07 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_07
USBFS_CB_d2h_std_ep_07:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_08 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_08
USBFS_CB_d2h_std_ep_08:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_09 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_09
USBFS_CB_d2h_std_ep_09:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_10 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_10
USBFS_CB_d2h_std_ep_10:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_11 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_11
USBFS_CB_d2h_std_ep_11:
ENDIF
IF (USB_CB_SRC_d2h_std_ep_12 & USB_NOT_SUPPORTED)
export  USBFS_CB_d2h_std_ep_12
USBFS_CB_d2h_std_ep_12:
ENDIF

; h2d_std_ep
IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ep_00
USBFS_CB_h2d_std_ep_00:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ep_01
USBFS_CB_h2d_std_ep_01:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ep_02
USBFS_CB_h2d_std_ep_02:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
export  USBFS_CB_h2d_std_ep_03
USBFS_CB_h2d_std_ep_03:
ENDIF

export  USBFS_Not_Supported
export _USBFS_Not_Supported
 USBFS_Not_Supported:
_USBFS_Not_Supported:
   mov    A, 0                         ; Count 0
   mov    X, USB_MODE_STALL_IN_OUT     ; Stall the request
   ljmp   USBFS_EP0_UPD_MODE_EXIT
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_d2h_std_dev_00
;
;  DESCRIPTION:   Get Device Status
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_STATUS                     = 00h
; wValue         : RESERVED                       = 0000h
; wIndex         : RESERVED                       = 0000h
; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
;
; The GET_DEVICE_STATUS request returns the current device status.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.LITERAL
GetStatusTransferDescrTable:
    TD_START_TABLE 1                   ; One entry
    TD_ENTRY    USB_DS_RAM, 2, USBFS_TransferBuffer, NULL_PTR    ; Intermediate Buffer
.ENDLITERAL
IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
export  USBFS_CB_d2h_std_dev_00
USBFS_CB_d2h_std_dev_00:
    mov     [USBFS_t2], 0              ; Use the UM temp var--Selector

    mov     [USBFS_TransferBuffer+1], 0    ; Use the UM Transfer Buffer
    mov     [USBFS_TransferBuffer], [USBFS_DeviceStatus]

    mov     A, >GetStatusTransferDescrTable    ; Get the ROM Address MSB
    mov     X, <GetStatusTransferDescrTable    ; Get the ROM Address LSB
    jmp     USBFS_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_dev_00 & USB_APP_SUPPLIED)
export  USBFS_CB_d2h_std_dev_00
USBFS_CB_d2h_std_dev_00:
    ljmp    APP_USBFS_CB_d2h_std_dev_00
ENDIF
ENDIF

;-----------------------------------------------------------------------------
;  USB 2nd Tier Dispactch Jump Tables for Standard Requests (based on bRequest)
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
;
;  DESCRIPTION:   The following tables dispatch to the Standard request handler
;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
USBFS_DT_d2h_std_dev:
;-----------------------------------------------------------------------------

    jmp     USBFS_CB_d2h_std_dev_00
    jmp     USBFS_CB_d2h_std_dev_01
    jmp     USBFS_CB_d2h_std_dev_02
    jmp     USBFS_CB_d2h_std_dev_03
    jmp     USBFS_CB_d2h_std_dev_04
    jmp     USBFS_CB_d2h_std_dev_05
    jmp     USBFS_CB_d2h_std_dev_06
    jmp     USBFS_CB_d2h_std_dev_07
    jmp     USBFS_CB_d2h_std_dev_08

USBFS_DT_d2h_std_dev_End:
USBFS_DT_d2h_std_dev_Size: equ (USBFS_DT_d2h_std_dev_End-USBFS_DT_d2h_std_dev) / 2
USBFS_DT_d2h_std_dev_Dispatch::
    mov     A, reg[USBFS_EP0DATA + bRequest]
    DISPATCHER USBFS_DT_d2h_std_dev, USBFS_DT_d2h_std_dev_Size, USBFS_Not_Supported

;-----------------------------------------------------------------------------
USBFS_DT_h2d_std_dev:
;-----------------------------------------------------------------------------

    jmp     USBFS_CB_h2d_std_dev_00
    jmp     USBFS_CB_h2d_std_dev_01
    jmp     USBFS_CB_h2d_std_dev_02
    jmp     USBFS_CB_h2d_std_dev_03
    jmp     USBFS_CB_h2d_std_dev_04
    jmp     USBFS_CB_h2d_std_dev_05
    jmp     USBFS_CB_h2d_std_dev_06
    jmp     USBFS_CB_h2d_std_dev_07
    jmp     USBFS_CB_h2d_std_dev_08
    jmp     USBFS_CB_h2d_std_dev_09

USBFS_DT_h2d_std_dev_End:
USBFS_DT_h2d_std_dev_Size: equ (USBFS_DT_h2d_std_dev_End-USBFS_DT_h2d_std_dev) / 2
USBFS_DT_h2d_std_dev_Dispatch::

    mov     A, reg[USBFS_EP0DATA + bRequest]
    DISPATCHER USBFS_DT_h2d_std_dev, USBFS_DT_h2d_std_dev_Size, USBFS_Not_Supported


;-----------------------------------------------------------------------------
USBFS_DT_d2h_std_ifc:
;-----------------------------------------------------------------------------

    jmp     USBFS_CB_d2h_std_ifc_00
    jmp     USBFS_CB_d2h_std_ifc_01
    jmp     USBFS_CB_d2h_std_ifc_02
    jmp     USBFS_CB_d2h_std_ifc_03
    jmp     USBFS_CB_d2h_std_ifc_04
    jmp     USBFS_CB_d2h_std_ifc_05
    jmp     USBFS_CB_d2h_std_ifc_06
    jmp     USBFS_CB_d2h_std_ifc_07
    jmp     USBFS_CB_d2h_std_ifc_08
    jmp     USBFS_CB_d2h_std_ifc_09
    jmp     USBFS_CB_d2h_std_ifc_10

USBFS_DT_d2h_std_ifc_End:
USBFS_DT_d2h_std_ifc_Size: equ (USBFS_DT_d2h_std_ifc_End-USBFS_DT_d2h_std_ifc) / 2
USBFS_DT_d2h_std_ifc_Dispatch::
    cmp     [USBFS_Configuration], 0   ; Is the device configured?
    jnz     .configured                ; Jump on configured
    jmp     _USBFS_Not_Supported       ; Stall the request if not configured
; Jump here if the device is configured
.configured:
    mov     A, reg[USBFS_EP0DATA + bRequest]
    DISPATCHER USBFS_DT_d2h_std_ifc, USBFS_DT_d2h_std_ifc_Size, USBFS_Not_Supported

;-----------------------------------------------------------------------------
USBFS_DT_h2d_std_ifc:
;-----------------------------------------------------------------------------

    jmp     USBFS_CB_h2d_std_ifc_00
    jmp     USBFS_CB_h2d_std_ifc_01
    jmp     USBFS_CB_h2d_std_ifc_02
    jmp     USBFS_CB_h2d_std_ifc_03
    jmp     USBFS_CB_h2d_std_ifc_04
    jmp     USBFS_CB_h2d_std_ifc_05
    jmp     USBFS_CB_h2d_std_ifc_06
    jmp     USBFS_CB_h2d_std_ifc_07
    jmp     USBFS_CB_h2d_std_ifc_08
    jmp     USBFS_CB_h2d_std_ifc_09
    jmp     USBFS_CB_h2d_std_ifc_10
    jmp     USBFS_CB_h2d_std_ifc_11

USBFS_DT_h2d_std_ifc_End:
USBFS_DT_h2d_std_ifc_Size: equ (USBFS_DT_h2d_std_ifc_End-USBFS_DT_h2d_std_ifc) / 2
USBFS_DT_h2d_std_ifc_Dispatch::
    cmp     [USBFS_Configuration], 0   ; Is the device configured?
    jnz     .configured                ; Jump on configured
    jmp     _USBFS_Not_Supported       ; Stall the request if not configured
; Jump here if the device is configured
.configured:
    mov     A, reg[USBFS_EP0DATA + bRequest]

   ;---------------------------------------------------
   ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
   ;---------------------------------------------------
   ; Add your custom Interface change logic below
   ;---------------------------------------------------

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

    DISPATCHER USBFS_DT_h2d_std_ifc, USBFS_DT_h2d_std_ifc_Size, USBFS_Not_Supported

;-----------------------------------------------------------------------------
USBFS_DT_d2h_std_ep:
;-----------------------------------------------------------------------------
    jmp     USBFS_CB_d2h_std_ep_00
    jmp     USBFS_CB_d2h_std_ep_01
    jmp     USBFS_CB_d2h_std_ep_02
    jmp     USBFS_CB_d2h_std_ep_03
    jmp     USBFS_CB_d2h_std_ep_04
    jmp     USBFS_CB_d2h_std_ep_05
    jmp     USBFS_CB_d2h_std_ep_06
    jmp     USBFS_CB_d2h_std_ep_07
    jmp     USBFS_CB_d2h_std_ep_08
    jmp     USBFS_CB_d2h_std_ep_09
    jmp     USBFS_CB_d2h_std_ep_10
    jmp     USBFS_CB_d2h_std_ep_11
    jmp     USBFS_CB_d2h_std_ep_12

USBFS_DT_d2h_std_ep_End:
USBFS_DT_d2h_std_ep_Size: equ (USBFS_DT_d2h_std_ep_End-USBFS_DT_d2h_std_ep) / 2
USBFS_DT_d2h_std_ep_Dispatch::
    cmp     [USBFS_Configuration], 0   ; Is the device configured?
    jnz     .configured                ; Jump on configured

    mov     A, reg[USBFS_EP0DATA + wIndexHi]   ; Is the request for EP0?
    mov     [USBFS_t2], A              ; Use the UM temp var--Selector
    mov     A, reg[USBFS_EP0DATA + wIndexLo]   ;
    or      [USBFS_t2], A              ; Use the UM temp var--Selector
    jz      .ep0_request

    jmp    _USBFS_Not_Supported        ; Stall the request if not configured
; Jump here if the device is configured or EP0 request
.configured:
.ep0_request:
    mov     A, reg[USBFS_EP0DATA + bRequest]
    DISPATCHER USBFS_DT_d2h_std_ep, USBFS_DT_d2h_std_ep_Size, USBFS_Not_Supported


;-----------------------------------------------------------------------------
USBFS_DT_h2d_std_ep:
;-----------------------------------------------------------------------------
    jmp     USBFS_CB_h2d_std_ep_00
    jmp     USBFS_CB_h2d_std_ep_01
    jmp     USBFS_CB_h2d_std_ep_02
    jmp     USBFS_CB_h2d_std_ep_03

USBFS_DT_h2d_std_ep_End:
USBFS_DT_h2d_std_ep_Size: equ (USBFS_DT_h2d_std_ep_End-USBFS_DT_h2d_std_ep) / 2
USBFS_DT_h2d_std_ep_Dispatch::
    cmp     [USBFS_Configuration], 0   ; Is the device configured?
    jnz     .configured                ; Jump on configured

    mov     A, reg[USBFS_EP0DATA + wIndexHi]   ; Is the request for EP0?
    mov     [USBFS_t2], A              ; Use the UM temp var--Selector
    mov     A, reg[USBFS_EP0DATA + wIndexLo]   ;
    or      [USBFS_t2], A              ; Use the UM temp var--Selector
    jz      .ep0_request

    jmp    _USBFS_Not_Supported        ; Stall the request if not configured
; Jump here if the device is configured or EP0 request
.configured:
.ep0_request:
    mov     A, reg[USBFS_EP0DATA + bRequest]
    DISPATCHER USBFS_DT_h2d_std_ep, USBFS_DT_h2d_std_ep_Size, USBFS_Not_Supported

USBFS_GetTableEntry_Local_Std:
    ljmp    USBFS_GetTableEntry

USBFS_NoDataStageControlTransfer_Local_Std:
    ljmp    USBFS_NoDataStageControlTransfer

;-----------------------------------------------
; Add custom application code for routines
; redefined by USB_APP_SUPPLIED in USB_HID.inc
;-----------------------------------------------

   ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
   ;---------------------------------------------------
   ; Insert your custom code below this banner
   ;---------------------------------------------------

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

;-----------------------------------------------------------------------------
; FUNCTION NAME: USBFS_CB_d2h_std_dev_06
;
; DESCRIPTION:   Get Device Descriptor
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_DESCRIPTOR                 = 06h
; wValue         : DESCRIPTOR TYPE | index        = xxxxh
; wIndex         : ZERO or LANG_ID                = xxxxh
; wLength        : SIZEOF_DESCRIPTOR              = --xxh
;
; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if
; the descriptor exists.
;
; The upper byte of wValue contains the descriptor type and
; the lower byte contains the descriptor index. wIndex
; contains either 0000h or the Language ID. wLength contains
; the descriptor length. The actual descriptor information is
; transferred in subsequent data packets.
;
;****************************************************************
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
export  USBFS_CB_d2h_std_dev_06
USBFS_CB_d2h_std_dev_06:
;-----------------------------------------------------------------------------
; Dispatch to the proper handler
;-----------------------------------------------------------------------------
    mov     A, reg[USBFS_EP0DATA+wValueHi]   ; Get the descrptor type
    asl     A                          ; Make it into a offset
    cmp     A, GET_DESCR_DISPATCH_SIZE           ; Validity check
    jnc     USBFS_Not_Supported

    jacc    GET_DESCR_DISPATCH

GET_DESCR_DISPATCH:
    jmp     USBFS_Not_Supported        ; Invalid
    jmp     USBFS_SendDeviceDescr      ; Device Descriptor
    jmp     USBFS_SendConfigDescr      ; Configuration Descriptor
IF  USBFS_bNumStringDescrs             ; Number of String Descriptor defined with the Wizard
    jmp     USBFS_SendStringDescr      ; String Descriptor
ELSE
    jmp     USBFS_Not_Supported        ; Not supported if we don't have
                                              ; any String Descriptor
ENDIF

GET_DESCR_DISPATCH_END:
GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)
;-----------------------------------------------------------------------------
; Configuration Descriptor Handler
;-----------------------------------------------------------------------------
USBFS_SendConfigDescr:
    call    USBFS_GET_DEVICE_TABLE_ENTRY
    swap    A, X
    add     A, 2                       ; We want the pointer to the descriptor table (second entry)
    swap    A, X
    adc     A, 0                       ; Don't forget the carry
    mov     [USBFS_t2], USBFS_t1       ; Set up the destination
    call    USBFS_GETWORD              ; Get the pointer

    mov     A, [USBFS_t1]              ; Pointer MSB
    mov     X, [USBFS_t1+1]            ; Pointer LSB

    push    A                          ; Save the MSB

    mov     A, reg[USBFS_EP0DATA+wValueLo]    ; Get the descrptor index
    mov     [USBFS_t2], A              ; Use the UM temp var--Selector
    pop     A                          ; Need the MSB for the range check
    push    A                          ; Save the MSB for after the range check
    romx                               ; First entry is the table size (only a byte)
    cmp     A, [USBFS_t2]              ; Range check
    jnc     .range_ok

    pop     A                          ; Fix the stack
    jmp     USBFS_Not_Supported

.range_ok:
    pop     A                          ; Get the MSB back
    jmp     USBFS_GetTableEntry_Local_Std
;-----------------------------------------------------------------------------
; Device Descriptor Handler
;-----------------------------------------------------------------------------
USBFS_SendDeviceDescr:
    mov     [USBFS_t2], [USBFS_bCurrentDevice]    ; Use the UM temp var--Selector
    mov     A, >USBFS_DEVICE_DESCR_TABLE    ; Get the ROM Address MSB
    mov     X, <USBFS_DEVICE_DESCR_TABLE    ; Get the ROM Address LSB
    romx                               ; First entry is the table size (only a byte)
    cmp     A, [USBFS_t2]              ; Range check
    jc      USBFS_Not_Supported

    mov     A, >USBFS_DEVICE_DESCR_TABLE    ; Get the ROM Address MSB

    jmp     USBFS_GetTableEntry_Local_Std
;-----------------------------------------------------------------------------
; String Descriptor Handler
;-----------------------------------------------------------------------------
IF  USBFS_bNumStringDescrs    ; Not needed if we don't have any String Descriptors
USBFS_SendStringDescr:
    mov     A, reg[USBFS_EP0DATA+wValueLo]    ; Get the descrptor index
    mov     [USBFS_t2], A              ; Use the UM temp var--Selector

    mov     A, >USBFS_StringTable      ; Get the ROM Address MSB
    mov     X, <USBFS_StringTable      ; Get the ROM Address LSB
    romx                               ; First entry is the table size (only a byte)
    cmp     A, [USBFS_t2]              ; Range check
    jc      USBFS_Not_Supported

    mov     A, >USBFS_StringTable      ; Get the ROM Address MSB

    jmp     USBFS_GetTableEntry_Local_Std
ENDIF
ELSE
IF (USB_CB_SRC_d2h_std_dev_06 & USB_APP_SUPPLIED)
export  USBFS_CB_d2h_std_dev_06
USBFS_CB_d2h_std_dev_06:
    ljmp    APP_USBFS_CB_d2h_std_dev_06
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_d2h_std_dev_08
;
;  DESCRIPTION:   Get Device Configuration
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_CONFIGURATION              = 08h
; wValue         : RESERVED                       = 0000h
; wIndex         : RESERVED                       = 0000h
; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h
;
; The GET_DEVICE_CONFIGURATION request returns the currently
; selected device configuration number.
;
; request_value and request_index contain 0000h. request_length
; contains 0001h and the one-byte configuration number is returned
; in a separate data transfer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
.LITERAL
GetConfigTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY    USB_DS_RAM, 1, USBFS_Configuration, NULL_PTR    ; Current configuration
.ENDLITERAL
export  USBFS_CB_d2h_std_dev_08
USBFS_CB_d2h_std_dev_08:
    mov     [USBFS_t2], 0              ; Use the UM temp var--Selector
    mov     A, >GetConfigTransferDescrTable    ; Get the ROM Address MSB
    mov     X, <GetConfigTransferDescrTable    ; Get the ROM Address LSB
    jmp     USBFS_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_dev_08 & USB_APP_SUPPLIED)
export  USBFS_CB_d2h_std_dev_08
USBFS_CB_d2h_std_dev_08:
    ljmp    APP_USBFS_CB_d2h_std_dev_08
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_h2d_std_dev_01
;
;  DESCRIPTION:   Clear Device Feature
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : CLEAR_FEATURE                  = 01h
; wValue         : FEATURE_SELECTOR               = --xxh
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h
;
; The CLEAR_DEVICE_FEATURE request disables a particular feature
; for a device. The only feature supported for a device is the
; REMOTE_WAKEUP feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
export  USBFS_CB_h2d_std_dev_01
USBFS_CB_h2d_std_dev_01:
    mov     A, reg[USBFS_EP0DATA+wValueLo]    ; Get the Feature Selector
                                       ; Check against valid features
                                       ;  for device receipient
    cmp     A, USB_DEVICE_REMOTE_WAKEUP    ; Only remote wakeup is defined for clear
    jnz     USBFS_Not_Supported        ;
    and     [USBFS_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
    jmp     USBFS_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_01 & USB_APP_SUPPLIED)
export  USBFS_CB_h2d_std_dev_01
USBFS_CB_h2d_std_dev_01:
    ljmp    APP_USBFS_CB_h2d_std_dev_01
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_h2d_std_dev_03
;
;  DESCRIPTION:   Set Device Featue
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_FEATURE                    = 03h
; wValue         : FEATURE_SELECTOR               = --xxh
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h
;
; The SET_DEVICE_FEATURE request enables a particular feature
; on a device. The only feature supported for a device is the
; REMOTE_WAKEUP feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
export  USBFS_CB_h2d_std_dev_03
USBFS_CB_h2d_std_dev_03:
    mov     A, reg[USBFS_EP0DATA+wValueLo]    ; Get the Feature Selector
                                       ; Check against valid features
                                       ;  for device receipient
    cmp     A, USB_DEVICE_REMOTE_WAKEUP    ; Remote wakeup?
    jz      .remote_wakeup

    cmp     A, USB_TEST_MODE           ; Test Mode
    jz      .test_mode
; Flow here for any other selector is invalid for device receipient
    jmp     USBFS_Not_Supported
; Jump here to enable remote wake up
.remote_wakeup:
    or      [USBFS_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
    jmp     .finish
; Jump here to enable test mode
.test_mode:
    jmp     USBFS_Not_Supported
.finish:
    jmp     USBFS_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_03 & USB_APP_SUPPLIED)
export  USBFS_CB_h2d_std_dev_03
USBFS_CB_h2d_std_dev_03:
    ljmp    APP_USBFS_CB_h2d_std_dev_03
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_h2d_std_dev_05
;
;  DESCRIPTION:   Set Device Address
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Address
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_ADDRESS                    = 05h
; wValue         : DEVICE_ADDRESS                 = 00xxh
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h
;
; The SET_DEVICE_ADDRESS request sets the USB device address
; for all future USB accesses.
;
;****************************************************************
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
export  USBFS_CB_h2d_std_dev_05
USBFS_CB_h2d_std_dev_05:
      
    mov     [USBFS_fDataPending], USB_ADDRESS_CHANGE_PENDING       
    mov     A, reg[USBFS_EP0DATA+wValueLo]       
    mov     [USBFS_TransferBuffer], A       
                                                   
    jmp     USBFS_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_05 & USB_APP_SUPPLIED)
export  USBFS_CB_h2d_std_dev_05
USBFS_CB_h2d_std_dev_05:
    ljmp    APP_USBFS_CB_h2d_std_dev_05
ENDIF
ENDIF


;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_h2d_std_dev_09
;
;  DESCRIPTION:   Set Configuration
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_CONFIGURATION              = 09h
; wValue         : CONFIGURATION_VALUE            = --xxh
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h
;
; The SET_DEVICE_CONFIGURATION request selects a device
; configuration to be activated as the current configuration.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
export  USBFS_CB_h2d_std_dev_09
USBFS_CB_h2d_std_dev_09:
    call    USBFS_GET_DEVICE_TABLE_ENTRY    ; Get the selected device
    mov     [USBFS_t2], USBFS_t1       ; Set the GETWORD destination
    call    USBFS_GETWORD              ; Get the pointer to the CONFIG_LOOKUP table
                                       ; ITempW has the address
    mov     A, reg[USBFS_EP0DATA+wValueLo]    ; Get the configuration number
    mov     [USBFS_t2], A              ; Save it
    mov     A, [USBFS_t1]              ; Get the CONFIG_LOOKUP ROM Address MSB
    mov     X, [USBFS_t1+1]            ; Get the CONFIG_LOOKUP ROM Address LSB
    romx                               ; First entry is the table size (only a byte)
    cmp     A, [USBFS_t2]              ; Range check
    jc      USBFS_Not_Supported

; Refactored from the two loops below
    mov     [USBFS_Configuration], [USBFS_t2]    ; Save the config number

    cmp     [USBFS_t2], 0              ; Unconfigure?
    jz      .unconfigure

; Flow here to configure the endpoints
    mov     A, [USBFS_t1]              ; Get the CONFIG_LOOKUP ROM Address MSB
    mov     X, [USBFS_t1+1]            ; Get the CONFIG_LOOKUP ROM Address LSB
    inc     X                          ; Point to the first table entry
    adc     A, 0                       ;
    mov     [USBFS_t2], USBFS_t1       ; Set up the destination
    call    USBFS_GETWORD              ; Get the pointer to the CONFIG_LOOKUP table
                                       ; ITempW has the address
    mov     X, 0                       ; Start the index at 0, but we inc first
.configure_next:
    inc     X                          ; Do the next one
    push    X                          ; Save the endpoint number
    mov     A, [USBFS_t1]              ; Get the CONFIG_LOOKUP ROM Address MSB
    mov     X, [USBFS_t1+1]            ; Get the CONFIG_LOOKUP ROM Address LSB
    romx
    inc     [USBFS_t1+1]               ; Point to the next
    adc     [USBFS_t1], 0              ;
    pop     X
    call    ConfigureEP                ; X contains the EP number
                                       ; A contains the EP Direction
    mov     A, X                       ;
    cmp     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
    jnz     .configure_next            ; Do another one?
; Flow here when we are done
    jmp     .done

; Jump here to unconfigure the endpoints
.unconfigure:
    M8C_SetBank1	; _EP1MODE is in Bank 1
    mov     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
.unconfigure_next:
    mov     [X+USBFS_EndpointAPIStatus], NO_EVENT_ALLOWED   ; For the API
    mov     reg[X+USBFS_EP1MODE-1], USB_MODE_DISABLE   ; Disable the endpoint
    dec     X                          ; One more down
    jnz     .unconfigure_next          ; Don't unconfigure EP0
	M8C_SetBank0
.done:
    jmp     USBFS_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_09 & USB_APP_SUPPLIED)
export  USBFS_CB_h2d_std_dev_09
USBFS_CB_h2d_std_dev_09:
    ljmp    APP_USBFS_CB_h2d_std_dev_09
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_d2h_std_ifc_00
;
;  DESCRIPTION:   Get Interface Status
;
;****************************************************************
; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
; bRequest       : GET_STATUS                     = 00h
; wValue         : RESERVED                       = 0000h
; wIndex         : INTERFACE                      = --xxh
; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h
;
; The GET_INTERFACE_STATUS request returns status for the
; specified interface.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
.LITERAL
GetInterfaceStatusTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY        USB_DS_RAM, 2, USBFS_TransferBuffer, NULL_PTR    ; Reuse the transfer buffer
.ENDLITERAL
export  USBFS_CB_d2h_std_ifc_00
USBFS_CB_d2h_std_ifc_00:
    mov     [USBFS_TransferBuffer], 0       ; Zero the transfer buffer
    mov     [USBFS_TransferBuffer+1], 0    ;

    mov     [USBFS_t2], 0              ; Use the UM temp var--Selector
    mov     A, >GetInterfaceStatusTransferDescrTable    ; Get the ROM Address MSB
    mov     X, <GetInterfaceStatusTransferDescrTable    ; Get the ROM Address LSB

    jmp     USBFS_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_APP_SUPPLIED)
export  USBFS_CB_d2h_std_ifc_00
USBFS_CB_d2h_std_ifc_00:
    ljmp    APP_USBFS_CB_d2h_std_ifc_00
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_d2h_std_ifc_10
;
;  DESCRIPTION:   Get Interface
;
;****************************************************************
; STANDARD INTERFACE IN REQUEST: Get_Interface
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
; bRequest       : GET_INTERFACE                  = 0Ah
; wValue         : RESERVED                       = 0000h
; wIndex         : INTERFACE                      = xxxxh
; wLength        : SIZEOF_GET_INTERFACE           = 0001h
;
; The GET_INTERFACE request returns the selected alternate
; setting for the specified interface.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
.LITERAL
GetInterfaceTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY        USB_DS_RAM, 1, USBFS_TransferBuffer, NULL_PTR    ; Reuse the transfer buffer
.ENDLITERAL
export  USBFS_CB_d2h_std_ifc_10
USBFS_CB_d2h_std_ifc_10:
    mov     A, reg[USBFS_EP0DATA+wIndexLo]    ; Get the interface number
    cmp     A, 3h                      ; Valid interface number? (UM Parameter: NumInterfaces)
    jnc     USBFS_Not_Supported

    mov     X, A                       ; The interface number is the index into alternates settings table

    mov     A, [X + USBFS_InterfaceSetting]    ; Save the current interface setting
    mov     [USBFS_TransferBuffer], A       ; into the transfer buffer

    mov     [USBFS_t2], 0              ; Use the UM temp var--Selector
    mov     A, >GetInterfaceTransferDescrTable    ; Get the ROM Address MSB
    mov     X, <GetInterfaceTransferDescrTable    ; Get the ROM Address LSB

    jmp     USBFS_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_ifc_10 & USB_APP_SUPPLIED)
export  USBFS_CB_d2h_std_ifc_10
USBFS_CB_d2h_std_ifc_10:
    ljmp    APP_USBFS_CB_d2h_std_ifc_10
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_d2h_std_ep_00
;
;  DESCRIPTION:   Get Endpoint Status
;
;****************************************************************
; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h
; bRequest       : GET_STATUS                     = 00h
; wValue         : RESERVED                       = 0000h
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h
;
; The GET_ENDPOINT_STATUS request returns status for the specified
; endpoint.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
export  USBFS_CB_d2h_std_ep_00
USBFS_CB_d2h_std_ep_00:
    mov     A, reg[USBFS_EP0DATA+wIndexLo]    ; Get the endpoint number
    and     A, ~USB_DIR_IN             ; Strip off the direction bit
    cmp     A, USB_NUM_ENDPOINTS       ; Range check
    jnc     USBFS_Not_Supported

    mov     X, A                       ; The endpoint number is the index

    mov     [USBFS_t2], 0              ; Use the UM temp var--Selector

    mov     [USBFS_TransferBuffer + 1], 0    ; Use the UM Transfer Buffer
    mov     A, [X + USBFS_EndpointStatus]    ; Get the status
    mov     [USBFS_TransferBuffer], A    ; Save it in the report

    mov     A, >GetStatusTransferDescrTable    ; Get the ROM Address MSB
    mov     X, <GetStatusTransferDescrTable    ; Get the ROM Address LSB

    jmp     USBFS_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_ep_00 & USB_APP_SUPPLIED)
export  USBFS_CB_d2h_std_ep_00
USBFS_CB_d2h_std_ep_00:
    ljmp    APP_USBFS_CB_d2h_std_ep_00
ENDIF
ENDIF

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_h2d_std_ep_01
;
;  DESCRIPTION:   Clear Endpoint Feature
;
;****************************************************************
; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
; bRequest       : CLEAR_FEATURE                  = 01h
; wValue         : FEATURE_SELECTOR               = --xxh
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : RESERVED                       = 0000h
;
; The CLEAR_ENDPOINT_FEATURE request disables a particular
; feature for an endpoint.
;
; The only feature supported for an endpoint is the EP_HALT
; feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
export  USBFS_CB_h2d_std_ep_01
USBFS_CB_h2d_std_ep_01:
    mov     A, reg[USBFS_EP0DATA+wValueLo]    ; Get the feature selector
    cmp     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
    jnz     USBFS_Not_Supported

    mov     A, reg[USBFS_EP0DATA+wIndexLo]    ; Get the Endpoint number
    and     A, ~USB_DIR_IN             ; Strip off the direction bit
    cmp     A, 0                       ; Since we can't halt the Control Endpoint
    jz      .done

    cmp     A, USB_NUM_ENDPOINTS       ; Range check
    jnc     USBFS_Not_Supported

    mov     X, A                       ; Endpoint number is the index
    and     [X+USBFS_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT    ; Clear the endpoint halt

;mykt_ukr    index   USBFS_USB_EP_BIT_LOOKUP	   ; Find bit position for endpoint
    push X
    add     A, <USBFS_USB_EP_BIT_LOOKUP           ; endpoint address LSB
    mov     X, >USBFS_USB_EP_BIT_LOOKUP           ; endpoint address MSB
    swap    A, X
    adc     A, 0
    romx
    pop X

    xor     A, FFh
    and     [USBFS_EPDataToggle], A ; Clear the data toggle for this endpoint

    tst     reg[USBFS_EP0DATA+wIndexLo], USB_DIR_IN    ; IN or OUT endpoint?
    M8C_SetBank1	                      ; For EP1_MODE register
    jnz     .in

    ; Mark endpoint as empty so it will be reloaded
    mov     [X+USBFS_EndpointAPIStatus], NO_EVENT_PENDING
    mov     reg[X + USBFS_EP1MODE - 1], USB_MODE_ACK_OUT    ; ACK the endpoint
    jmp     .done
.in:
    mov     [X+USBFS_EndpointAPIStatus], EVENT_PENDING
    mov     reg[X + USBFS_EP1MODE - 1], USB_MODE_NAK_IN    ; NAK the endpoint
.done:
	M8C_SetBank0
    jmp     USBFS_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_ep_01 & USB_APP_SUPPLIED)
export  USBFS_CB_h2d_std_ep_01
USBFS_CB_h2d_std_ep_01:
    ljmp    APP_USBFS_CB_h2d_std_ep_01
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USBFS_CB_h2d_std_ep_03
;
;  DESCRIPTION:   Set Endpoint Feature
;
;****************************************************************
; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
; bRequest       : SET_FEATURE                    = 03h
; wValue         : FEATURE_SELECTOR               = --xxh
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : RESERVED                       = 0000h
;
; The SET_ENDPOINT_FEATURE request enables a particular feature
; for a specific endpoint. The only feature supported for an
; endpoint is the EP_HALT feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A and X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
export  USBFS_CB_h2d_std_ep_03
USBFS_CB_h2d_std_ep_03:
    mov     A, reg[USBFS_EP0DATA+wValueLo]    ; Get the feature selector
    cmp     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
    jnz     USBFS_Not_Supported

    mov     A, reg[USBFS_EP0DATA+wIndexLo]    ; Get the Endpoint number
    and     A, ~USB_DIR_IN             ; Strip off the direction bit
    cmp     A, 0                       ; Never halt the Control Endpoint
    jz      .done

    cmp     A, USB_NUM_ENDPOINTS       ; Range check
    jnc     USBFS_Not_Supported

    mov     X, A                       ; Endpoint number is the index

    or      [X+USBFS_EndpointStatus], USB_ENDPOINT_STATUS_HALT    ; Halt the endpoint
    mov     [X+USBFS_EndpointAPIStatus], NO_EVENT_ALLOWED

    tst     reg[USBFS_EP0DATA+wIndexLo], USB_DIR_IN    ; IN or OUT endpoint?
    M8C_SetBank1	                      ; For EP1_MODE register
    jnz     .in

    mov     reg[X + USBFS_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT    ; Stall the endpoint
    jmp     .done
.in:
    mov     reg[X + USBFS_EP1MODE - 1], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN    ; Stall the endpoint
.done:
	M8C_SetBank0
    jmp     USBFS_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_ep_03 & USB_APP_SUPPLIED)
export  USBFS_CB_h2d_std_ep_03
USBFS_CB_h2d_std_ep_03:
    ljmp    APP_USBFS_CB_h2d_std_ep_03
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ConfigureEP
;
;  DESCRIPTION:   Configure an endpoint
;
;  ARGUMENTS:    A contains the endpoint direction
;                X contains the endpoint number
;
;  RETURNS:
;
;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
ConfigureEP:
    cmp     A, USB_DIR_UNUSED          ; Is this endpoint unused?
    jnz     .enable                    ; Only enable it if it is used
    ret                                ; Quick exit if this endpoint is unused

; Jump here to enable an endpoint
.enable:
    push    A		                        ; Save the endpoint direction
    mov     A, X	                      ; We are using a jacc to dispatch to enable the interrupt
    asl     A		                        ;
    jacc    .EP_INT_ENABLE             ;


.EP_INT_ENABLE:
    jmp     .EP0IntEnable              ; Enable EP0
    jmp     .EP1IntEnable              ; Enable EP1
    jmp     .EP2IntEnable              ; Enable EP2
    jmp     .EP3IntEnable              ; Enable EP3
    jmp     .EP4IntEnable              ; Enable EP4

; Jump here to enable EP0 Interrupts
.EP0IntEnable:
    M8C_EnableIntMask USBFS_INT_REG, USBFS_INT_EP0_MASK
;    jmp   .exit2
    jmp     .cont
.EP1IntEnable:
    M8C_EnableIntMask USBFS_INT_REG, USBFS_INT_EP1_MASK
    jmp     .cont
.EP2IntEnable:
    M8C_EnableIntMask USBFS_INT_REG, USBFS_INT_EP2_MASK
    jmp     .cont
.EP3IntEnable:
    M8C_EnableIntMask USBFS_INT_REG, USBFS_INT_EP3_MASK
    jmp     .cont
.EP4IntEnable:
    M8C_EnableIntMask USBFS_INT_REG, USBFS_INT_EP4_MASK
	jmp     .cont

; Jump or flow here to continue configuring the endpoint
;.contEP0:
;    pop   A                           ; Get the endpoint direction back
;    and   A, USB_DIR_IN               ; Is it an IN endpoint?
;    jnz   .inEP0                      ; Jump on IN
; Flow here for an OUT Endpoint
;    mov   [USBFS_TempMode], USB_MODE_NAK_OUT   ; NAK the endpoint
;    jmp   .exit2
; Jump here for an IN Endpoint
;.inEP0:
;    mov   [USBFS_TempMode], USB_MODE_NAK_IN   ; NAK the endpoint
;	jmp   .exit2
.cont:
    mov     A, X	                      ; Get the endpoint number from X

;mykt_ukr     index   USBFS_USB_EP_BIT_LOOKUP	   ; Find bit position for endpoint
    push X	
    add     A, <USBFS_USB_EP_BIT_LOOKUP           ; endpoint address LSB
    mov     X, >USBFS_USB_EP_BIT_LOOKUP           ; endpoint address MSB
    swap    A, X
    adc     A, 0
    romx
    pop X
	
    xor     A, FFh
    and     [USBFS_EPDataToggle], A ; Clear the data toggle for this endpoint

    and     [X+USBFS_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT    ; Clear any endpoint halts

; if endpoint 0 set EP0MODE
; then exit
;    mov     A, X	                     ; Get the endpoint number from X
;    cmp     A, EP0	                   ; Is this endpoint zero?
;    jnz     .enable                   ; Only enable it if it is used

    M8C_SetBank1
    pop     A                          ; Get the endpoint direction back
    and     A, USB_DIR_IN              ; Is it an IN endpoint?
    jnz     .in                        ; Jump on IN
; Flow here for an OUT Endpoint
    mov     reg[X+USBFS_EP1MODE-1], USB_MODE_ACK_OUT   ; ACK the endpoint
    mov     [X+USBFS_EndpointAPIStatus], NO_EVENT_PENDING   ; For the API
    jmp     .exit1
; Jump here for an IN Endpoint
.in:
    mov     reg[X+USBFS_EP1MODE-1], USB_MODE_NAK_IN   ; NAK the endpoint
    mov     [X+USBFS_EndpointAPIStatus], EVENT_PENDING   ; For the API
; Jump or flow here to set the API event and exit
.exit1:
	M8C_SetBank0
.exit2:
;    mov   [X+USBFS_EPDataToggle], 0    ; Clear all EP data toggles?  Is this right?
    ret

; End of File USBFS_std.asm
